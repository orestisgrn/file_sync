Εργασία 1 - Προγραμματισμός Συστήματος 2024/25

Ονοματεπώνυμο:    Γκαράνης Ορέστης
Αριθμός μητρώου:  sdi2200282 / 1115202200282

Ο κώδικας γίνεται compile με: make
Τα object files και τα εκτελέσιμα διαγράφονται με: make clean

Ο κώδικας είναι δομημένος στα παρακάτω αρχεία:

fss_manager.c             : H main του εκτελέσιμου fss_manager
fss_console.c             : H main του εκτελέσιμου fss_console
worker.c                  : H main του εκτελέσιμου worker
utils.h                   : Χρήσιμα enums, macros, και ορισμοί που χρησιμοποιούνται σε πολλαπλά αρχεία
worker.h                  : Header για το worker.c
sync_info_lookup.c/.h     : Η δομή δεδομένων για αποθήκευση εγγραφών σχετικά με τους παρακολουθούμενους
                            καταλόγους (sync_info_mem_store)
hashtable_path.c/.h       : Πίνακας κατακερματισμού για αναζήτηση προς το source path κάποιας εγγραφής
                            (χρησιμοποιείται στην sync_info_lookup)
hashtable_watchdesc.c/.h  : Πίνακας κατακερματισμού για αναζήτηση προς το watch descriptor κάποιας εγγραφής
                            (χρησιμοποιείται στην sync_info_lookup)
list.c/.h                 : Λίστες που χρησιμοποιούνται για αποθήκευση των εγγραφών στα hashtables της δομής του sync_info_lookup
string.c/.h               : Δυναμικά strings
queue.c/.h                : Ουρά για αποθήκευση εγγραφών σχετικά με workers που πρέπει να εκτελεστούν μόλις τερματίσουν ήδη τρέχοντες
                            workers στην περίπτωση που έχουμε φτάσει στο όριο των workers


Λειτουργία του προγράμματος:


fss_manager: Το πρόγραμμα αρχικά αρχικοποιεί τις διάφορες δομές δεδομένων που χρησιμοποιεί και έπειτα διαβάζει τις εγγραφές
             του config file, εκκινώντας παράλληλα και το συγχρονισμό των εγγραφών αυτών και αποθηκεύοντας τες στην
             sync_info_mem_store. Η sync_info_mem_store που είναι τύπου Sync_Info_Lookup, είναι υλοποιημένη ως ένας πίνακας
             κατακερματισμού που αποθηκεύει εγγραφές struct sync_info_rec (τύπος ορισμένος στο utils.h), με κλειδί ως προς
             το source directory (hashtable_path), και επίσης χρησιμοποιεί έναν επιπλέον πίνακα κατακερματισμού για αποθήκευση
             αναφορών σε ήδη υπάρχουσες εγγραφές του hashtable_path, για αναζήτηση των monitored directories ως προς το watch
             descriptor που χρησιμοποιείται για την παρακολούθηση τους (hashtable_watchdesc).

             Έπειτα, φτάνει στο κύριο loop του προγράμματος, στο οποίο αρχικά περιμένει για I/O δραστηριότητα στα file descriptors
             για inotify, signalfd, και στο fss_in, χρησιμοποιώντας την συνάρτηση poll. Εάν βρεθεί δραστηριότητα σε κάποιο από αυτά τα
             file descriptors, τότε πράττουμε αναλόγως: εάν έχουμε inotify event, κάνουμε fork και exec έναν νέο worker (με την
             spawn_worker), εάν έχουμε signal στο signalfd μαζεύουμε τους τερματισμένους workers, και εκκινούμε workers που υπάρχουν
             στην ουρά, (με την collect_workers), και εάν έχουμε είσοδο από το fss_in, διαβάζουμε την εντολή που λάβαμε από το console
             και την επεξεργαζόμαστε (με την process_command), εκτελώντας την εάν είναι έγκυρη εντολή.

             Για την διαχείριση των workers χρησιμοποιούνται δύο δομές δεδομένων, η worker_queue, και η worker_table. Η worker_queue
             διατηρεί εγγραφές τύπου struct work_rec (τύπος ορισμένος στο queue.h), οι οποίες διατηρούν πληροφορίες για τον worker που
             πρέπει να εκκινηθεί όταν τερματίσουν workers. Η worker_table είναι ένα array τύπου struct worker_table_rec** και διατηρεί
             πληροφορίες για τους workers που εκτελούνται (πιο συγκεκριμένα για αυτούς που δεν έχουν "μαζευτεί" ακόμα από την
             collect_workers). Οι εγγραφές τύπου struct worker_table_rec (τύπος ορισμένος στο fss_manager.c), διατηρούν πληροφορίες
             όπως το pid του worker, τα pipes για επικοινωνία με τον worker, και αναφορά στην struct sync_info_rec εγγραφή του
             directory για το οποίο δουλεύει ο worker. Η δομή αυτή χρησιμοποιείται για αναζήτηση ως πρός το pid του worker που
             τερμάτισε στην collect_workers, για ενημέρωση της εγγράφης του καταλόγου.

             Μόλις ληφθεί η εντολή shutdown από το console, ο manager τερματίζει, αφού συλλέξει όλους τους τρέχοντες workers με την
             cleanup_workers (ίδια με την collect_workers, με την διαφορά ότι δεν είναι non-blocking).

             Το fss_console μπορεί να τρέξει μον εφόσον υπάρχει το fss_in που δημιουργεί ο manager. Ο manager επίσης διαγράφει τα
             fifos fss_in και fss_out που δημιουργεί κατά τον τερματισμό του, οπότε θεωρώντας ότι αυτά τα ονομάτα αρχείων είναι
             "δεσμευμένα", τότε το fss_console μπορεί να τρέξει μόνο εφόσον τρέχει και ο manager. O manager αποκρίνεται στο
             fss_console μέσω του fss_out, το οποίο ανοίγει μόνο όταν έρχεται εντολή, και κλείνει μόνο αφού επεξεργαστεί πλήρως την
             εντολή. Το fss_console, διαβάζει από το fss_out με blocking τρόπο, άρα τα διαβάσματα του τερματίζουν μόνο μόλις γίνει όλη
             η επεξεργασία της τρέχουσας εντολής. Το format με το οποίο επικοινωνούνε το console και ο manager φαίνεται στον κώδικα
             και στα comments του fss_console.c. Αντίστοιχα το format επικοινωνίας μεταξύ worker και manager φαίνεται στην συνάρτηση
             handle_worker_term του fss_console.c, που καλείται από την collect_workers.


Παραδοχές/Σχόλια:

            Κάθε source path που δίνεται στον manager, μετατρέπεται σε absolute path μέσω της realpath. Ανεξάρτητα από το πώς δόθηκε
            το source path, κάθε αναφορά σε αυτό από τον manager θα γίνεται με την χρήση του absolute path. Το ίδιο το absolute path
            χρησιμοποιείται ως key για αναζήτηση στην sync_info_mem_store. Για την παρούσα εργασία θεωρούμε ότι δεν θα γίνει διαγραφή
            ή μετονομασία των παρακολουθούμενων φακέλων. To target path δεν γίνεται normalized και εμφανίζεται όπως δόθηκε από τον
            χρήστη.

            Στην εντολή sync του console, για λόγους απλότητας, περιμένουμε μέχρι να τερματίσει οποιοσδήποτε worker που εργάζεται
            στο path, ανεξάρτητα από το εάν τρέχει κάποιoς full sync worker, ή έγινε spawn κάποιος worker για τις αναγκές της sync.
            (π.χ. μπορεί να εκτελεστεί εντολή sync χωρίς να υπαρχεί worker για το path, να γίνει spawn o worker, αλλά κάποια αλλαγή
            στο source path να εκκινησεί έναν worker, ο οποίος θα τελειώσει πριν το αρχικό full sync, και η εντολή sync θα ολοκληρωθεί
            πριν την ολοκλήρωση του sync που έκανε spawn)

            Τα directories που δίνονται για παρακολούθηση, καθώς και τα target directories τους θα πρέπει να υπάρχουν εκ των προτέρων.

